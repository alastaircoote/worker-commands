import { registerCommand, fireCommand } from "../command-registry";
import { RunCommand } from "../interfaces/run-command";
import { UpdatedNotification } from "../interfaces/updated-notification";

declare var self: ServiceWorkerGlobalScope;

export interface NotificationAction {
    action: string;
    title: string;
}

export interface TransformCacheValue {
    from: "cache";
    url: string;
}

export interface TransformCommandValue {
    from: "command";
    command: string;
    options: any;
}

export type Transformable<T> = T | TransformCacheValue | TransformCommandValue;

export interface ShowNotification {
    title: Transformable<string>;
    badge?: Transformable<string>;
    icon?: Transformable<string>;
    image?: Transformable<string>;
    body: Transformable<string>;
    data?: any;
    tag?: string;
    actions?: NotificationAction[];
    events?: { [name: string]: RunCommand<any> | RunCommand<any>[] };
}

export interface RemoveNotificationOptions {
    tag?: string;
}

async function transformOption(
    value?: string | TransformCacheValue | TransformCommandValue
): Promise<string | undefined> {
    if (!value || typeof value === "string") {
        // it isn't a calculated value
        return value;
    }

    if (value.from === "command") {
        return await fireCommand({
            command: value.command,
            options: value.options
        });
    } else if (value.from === "cache") {
        let match = await caches.match(value.url);
        if (!match) {
            // If we don't have an entry in the cache we just try to use the remote
            // URL instead. But log a warning, as this isn't intended behaviour.
            console.warn(`Notification tried to use ${value}, but no cache entry present`);
            return value.url;
        }

        // Otherwise, we turn the cached response into an array buffer, then
        // into a Base64 URL:

        let arrayBuffer = await match.arrayBuffer();

        let base64URL = await new Promise<string>((fulfill, reject) => {
            let reader = new FileReader();
            reader.onerror = reject;
            reader.onload = e => fulfill(reader.result);
            reader.readAsDataURL(new Blob([arrayBuffer]));
        });

        // and then set the value on our notification options:
        return base64URL;
    } else {
        throw new Error(`Didn't understand object transform`);
    }
}

async function showNotification(options: ShowNotification) {
    if (!options.title || !options.body) {
        throw new Error("Notification must, at at a minimum, provide title and body.");
    }

    // The showNotification command separates title from the rest of the options,
    // so we'll oblige
    const { title, events, body, icon, badge, image, ...nonTitleOptions } = options;

    // We support remote notifications reading out icons, badges and images from
    // the local cache or from a command:

    let [transformedIcon, transformedBadge, transformedImage, transformedBody] = await Promise.all([
        transformOption(icon),
        transformOption(badge),
        transformOption(image),
        transformOption(body)
    ]);

    let finalOptions = Object.assign({}, nonTitleOptions, {
        icon: transformedIcon,
        image: transformedImage,
        badge: transformedBadge,
        body: transformedBody
    });

    let finalTitle = await transformOption(title);

    if (!finalTitle) {
        throw new Error("No title in final result. Notification must have title.");
    }

    finalOptions.data = Object.assign(finalOptions.data || {}, {
        // We add this so that when we're looking at notificationclick etc. events
        // we can check whether this is a notification generated by this library
        // or not.
        __workerCommandNotification: true,
        __events: events
    });

    await self.registration.showNotification(finalTitle, finalOptions);
}

async function removeNotifications(removeOptions?: RemoveNotificationOptions, event?: NotificationEvent) {
    let tag = removeOptions ? removeOptions.tag : undefined;

    if (!tag && event) {
        event.notification.close();
    } else if (!tag) {
        throw new Error("Must provide a notificationevent or tag to remove notification");
    }

    let currentNotifications = await self.registration.getNotifications({ tag });

    currentNotifications.forEach((n: UpdatedNotification) => {
        if (checkIfLibraryNotification(n) === true) {
            n.close();
        }
    });
}

async function processNotificationClick(empty: void, e: NotificationEvent | undefined) {
    if (!e) {
        throw new Error("Cannot process notification click without also sending event");
    }

    let notification = e.notification as UpdatedNotification;
    if (checkIfLibraryNotification(notification) === false) {
        // This notification was not generated by our library, so ignore it.
        return;
    }

    if (!notification.data.__events) {
        // This notification does not have any event listeners.
        console.warn("Notification received a click event but has no events attached.");
        return;
    }

    let eventName = "click";
    if (e.action) {
        eventName = e.action;
    }

    let targetEvent = notification.data.__events["on" + eventName];

    if (!targetEvent) {
        console.error(`Notification received on${eventName} event, but no listener was attached`);
        return;
    }

    await fireCommand(targetEvent, e);
}

async function processNotificationClose(empty: void, e: NotificationEvent | undefined) {
    if (!e) {
        throw new Error("Cannot process notification click without also sending event");
    }
    let notification = e.notification as UpdatedNotification;
    if (checkIfLibraryNotification(notification) === false) {
        // This notification was not generated by our library, so ignore it.
        return;
    }

    if (!notification.data.__events || !notification.data.__events.onclose) {
        // Only 'info' level here because it isn't necessarily a mistake.
        console.info("Notification received a close event with no events attached.");
        return;
    }

    await fireCommand(notification.data.__events.onclose, e);
}

function checkIfLibraryNotification(notification: UpdatedNotification) {
    // We don't want to mess with any notifications not sent through this
    // library - so we can do this simple check:
    return notification.data && notification.data.__workerCommandNotification === true;
}

export function setup() {
    registerCommand("notification.show", showNotification);
    registerCommand("notification.close", removeNotifications);
    registerCommand("notification.process-click", processNotificationClick);
    registerCommand("notification.process-close", processNotificationClose);

    // We have these set up as specific commands so that we can attach listeners
    // for things like analytics later on.

    self.addEventListener("notificationclick", function(e) {
        e.waitUntil(fireCommand({ command: "notification.process-click" }, e));
    });

    self.addEventListener("notificationclose", function(e) {
        e.waitUntil(fireCommand({ command: "notification.process-close" }, e));
    });
}
